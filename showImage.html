<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>Strela Walk</title>
    <link href="https://fonts.googleapis.com/css2?family=Fjalla+One&display=swap" rel="stylesheet">
    <style>
        body{
            background: rgb(73,118,177);
            background: linear-gradient(180deg, rgba(73,118,177,1) 0%, rgba(157,185,188,1) 31%, rgba(241,241,49,1) 100%);
            margin:0px;
            padding:0px;
            width:100vw;
            min-height:100vh;
        }
        #nav{
            position:absolute;
            z-index:500;
            top:50px;
            right:50px;
            background: rgba(241,241,49,0.6);

        }

        #nav a{
            font-family: 'Fjalla One', sans-serif;
            color:black;
        }

        .label{
            font-family: 'Fjalla One', sans-serif;
            color:#180e3d;
            font-size:1.1rem;
            background-color:rgba(0,0,0,0.5);
            display:none;
        }
        .label.show{
            display:block;
        }

        #canvas{

            position:absolute;
        }
        canvas{
            overflow:hidden;
        }
        img{
            display:block;
        }
    </style>
</head>
<body>

<canvas id="canvas" style="width: 100%; height: 100%;"></canvas>

<nav id="nav"><a href="#" data-longitude="9.814014308596548" data-latitude="46.8011922" data-altitude="1856">Alpengarten Schatzalp</a></nav>


<script src="lib/three.min.js"></script>
<script src="lib/OrbitControls.js"></script>
<!-- <script src="../deps/stats.min.js"></script> -->
<script src="lib/threelet.min.js"></script>

<script src="lib/three-geo.min.js"></script>

<script src="lib/d3.v3.js"></script>
<script src="lib/tween.js"></script>
<!-- <script src="../../target/three-geo.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>

<script type="module">
    import { CSS2DRenderer, CSS2DObject } from 'https://threejs.org/examples/jsm/renderers/CSS2DRenderer.js';

    import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';

    class ColorGUIHelper {
        constructor(object, prop) {
            this.object = object;
            this.prop = prop;
        }
        get value() {
            return `#${this.object[this.prop].getHexString()}`;
        }
        set value(hexString) {
            this.object[this.prop].set(hexString);
        }
    }
    //https://github.com/w3reality/three-geo


    const raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(), INTERSECTED;
    var realmouse = new THREE.Vector2();

    var clickables = [];

    var labelRenderer;

    const canvas = document.getElementById("canvas");
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 0.001, 1000 );
    camera.position.set(0, 0.4, 0.5);

    const renderer = new THREE.WebGLRenderer({ canvas, alpha:true });
    renderer.setSize( window.innerWidth, window.innerHeight );

    labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize( window.innerWidth, window.innerHeight );
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    document.body.appendChild( labelRenderer.domElement );

    const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    controls.update();

    //lights
    const color = 0xFFFFFF;
    const intensity = 2;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 1, 1);
    light.target.position.set(0, 0, 1);
    scene.add(light);
    scene.add(light.target);



    const render = () => {
        //stats.update();
        renderer.render(scene, camera);
    };

    controls.addEventListener('change', render);
    render();

    document.addEventListener( 'mousemove', onDocumentMouseMove, false );

    function onDocumentMouseMove( event ) {

        event.preventDefault();

        realmouse.x = event.clientX;
        realmouse.y = event.clientY;

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    }


    //..................images with geolocation .......................
    //https://awik.io/extract-gps-location-exif-data-photos-using-javascript/

    const putSphere = (pos, src) => {
        const { proj, unitsPerMeter } = tgeo.getProjection(origin, radius);
        let coord = proj([pos.lat, pos.lng]);

        let geometry = new THREE.SphereGeometry( 30 * unitsPerMeter, 32, 32 );
        //var geometry = new THREE.BoxBufferGeometry( 50 * unitsPerMeter, 50 * unitsPerMeter, 50 * unitsPerMeter );

        geometry.imgpath = src;
        let material = new THREE.MeshPhongMaterial( {color: "#93121c"} );
        let sphere = new THREE.Mesh( geometry, material );
        sphere.position.x = coord[0];
        sphere.position.y = (pos.alt ) * unitsPerMeter;
        sphere.position.z = -coord[1];

        clickables.push(sphere);
        scene.add( sphere );

        var loader = new THREE.ImageLoader();

        // load a image resource
        loader.load(
            // resource URL
            src,

            // onLoad callback
            function ( image ) {

                var imgcanvas  = document.createElement('canvas');

                 imgcanvas.width = 160;
                 imgcanvas.height = 120;
                 var context = imgcanvas.getContext( '2d' );
                 context.drawImage( image, 0, 0 );

                var labelDiv = document.createElement( 'div' );
                labelDiv.className = 'label';
                //labelDiv.textContent = "Image"+src;
                labelDiv.style.marginTop = '-65px';
                labelDiv.appendChild(imgcanvas);

                var Label = new CSS2DObject( labelDiv );
                Label.position.set( 0,0,0 );
                sphere.add( Label );
            },

            // onProgress callback currently not supported
            undefined,

            // onError callback
            function () {
                console.error( 'An error happened.' );
            }
        );




    }

    var imagesArr = [];
    imagesArr.push("./assets/images/IMG_6162.jpg");
    imagesArr.push("./assets/images/IMG_6163.jpg");
    imagesArr.push("./assets/images/IMG_6164.jpg");
    imagesArr.push("./assets/images/IMG_6165.jpg");
    imagesArr.push("./assets/images/IMG_6166.jpg");
    imagesArr.push("./assets/images/IMG_6167.jpg");
    imagesArr.push("./assets/images/IMG_6168.jpg");
    imagesArr.push("./assets/images/IMG_6169.jpg");
    imagesArr.push("./assets/images/IMG_6170.jpg");
    imagesArr.push("./assets/images/IMG_6171.jpg");
    imagesArr.push("./assets/images/IMG_6172.jpg");
    imagesArr.push("./assets/images/IMG_6173.jpg");
    const loadGeolocImages = () => {
        for(let j=0;j<imagesArr.length;j++){
            let img = new Image();

            img.onload = function() {
                EXIF.getData(this, function() {
                    let pos = {};
                    // Calculate latitude decimal
                    let myData = this;
                    //console.log(myData.exifdata);
                    let latDegree = myData.exifdata.GPSLatitude[0].numerator;
                    let latMinute = myData.exifdata.GPSLatitude[1].numerator;
                    let latSecond = myData.exifdata.GPSLatitude[2].numerator / myData.exifdata.GPSLatitude[2].denominator;
                    let latDirection = myData.exifdata.GPSLatitudeRef;

                    pos.lat = ConvertDMSToDD(latDegree, latMinute, latSecond, latDirection);
                    //console.log(latFinal);

                    // Calculate longitude decimal
                    let lonDegree = myData.exifdata.GPSLongitude[0].numerator;
                    let lonMinute = myData.exifdata.GPSLongitude[1].numerator;
                    let lonSecond = myData.exifdata.GPSLongitude[2].numerator / myData.exifdata.GPSLongitude[2].denominator;
                    let lonDirection = myData.exifdata.GPSLongitudeRef;

                    pos.lng = ConvertDMSToDD(lonDegree, lonMinute, lonSecond, lonDirection);
                    //console.log(lonFinal);

                    pos.alt= parseInt(myData.exifdata.GPSAltitude.numerator);

                    putSphere(pos, imagesArr[j]);



                });
            }
            img.src = imagesArr[j];
        }
    };

    loadGeolocImages();





    function ConvertDMSToDD(degrees, minutes, seconds, direction) {

        var dd = parseFloat(degrees) + parseFloat(minutes/60) + parseFloat(seconds/3600);


        if (direction == "S" || direction == "W") {
            dd = dd * -1;
        }

        return dd;
    }


    //..................show image .......................
    const showImageCanvas = (el) => {

        Array.from(document.getElementsByClassName("label")).forEach(function(item) {
            item.className = item.className.replace(/\bshow\b/g, "");
            }
        );

        el.children[0].element.classList.add("show");
    }


    //..................three-geo .......................
    const ioToken = 'pk.eyJ1IjoiamRldmVsIiwiYSI6ImNqemFwaGJoZjAyc3MzbXA1OGNuODBxa2EifQ.7M__SgfWZGJuEiSqbBXdoQ';
    const tgeo = new ThreeGeo({
        tokenMapbox: 'pk.eyJ1IjoiaHp1ZWxsaWciLCJhIjoiY2tjbmt1MjQwMGMzcDJybGZtcGR3NmR4aCJ9.HMZtdVsH8vPFyK5r5KmOHA' // <---- set your Mapbox API token here

    });
    //tgeo.setApiSatellite('./customtiles/');

    if (tgeo.tokenMapbox === ioToken && window.location.origin !== 'https://w3reality.github.io') {
        const warning = 'Please set your own Mapbox API token in the ThreeGeo constructor.';
        alert(warning);
        throw warning;
    }

    //var proj, unitsPerMeter  = tgeo.getProjection(origin, radius);




    const origin = [46.802745, 9.835970];
    const radius = 6.0;

    var myColor = d3.scale.linear().domain([1000, 1500,2000, 2500, 3000]).range(["#325192", "#364037", "#3f5737", "#d7dd49", "#d2ddf3"]);
    //..................Terrain.......................
    // Hack for custom tiles ... @todo better: https://docs.mapbox.com/help/tutorials/georeferencing-imagery/
    var data=[];
    getImg("./customtiles/2159-1443-sw.jpg", 0);
    getImg("./customtiles/2159-1444-sw.jpg", 1);
    getImg("./customtiles/2160-1443-sw.jpg", 2);
    getImg("./customtiles/2160-1444-sw.jpg", 3);


    (async () => {

        const terrain = await tgeo.getTerrainRgb(origin, radius, 12);
         terrain.rotation.x = - Math.PI/2;
         let child = 0
         terrain.children.forEach(mesh => {
             //mesh.material.color.setHex(0xcccccc);
             mesh.material.wireframe = true;

             //mesh.material.alphaMap = mesh.material.map;
             //mesh.material.map = null;
    //new Uint8Array(arrayBuffer);
             switch(child){
                 case(0):
                     mesh.material.map.image.data = data[0];

                     //console.log(data);
                     break;
                case(1):
                    mesh.material.map.image.data = data[1];

                 //console.log(data);
                    break;
                case(2):
                    mesh.material.map.image.data = data[2];

                 //console.log(data);
                    break;
                case(3):
                    mesh.material.map.image.data = data[3];

                 //console.log(data);
                    break;
             }


             mesh.material.opacity=1;
             mesh.material.wireframeLinewidth = 1;
             child++;
         });
         //console.log(terrain)
         scene.add(terrain);



        d3.xml('assets/Tracks_2.gpx', 'application/xml', gpxParser);



    })();


    function getImg(url, key){
        var canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d');
        //size canvas
        canvas.width = 512;
        canvas.height = 512;


//create image, set src to base64 and onload draw to canvas
        var image = new Image();
        image.src = url;

        image.onload = (function(canvas, ctx){
            return function(){
                ctx.drawImage(this, 0, 0);

                //now we can finally get a Uint8ClampedArray
                var imageData = ctx.getImageData(0, 0, 512, 512);
                data[key]=imageData.data;

            }
        })(canvas, ctx);

    }

    //..................Track.......................
    function gpxParser(gpx) {
        var tracks = gpx.getElementsByTagName('trk');

        const { proj, unitsPerMeter } = tgeo.getProjection(origin, radius);


        for (let i = 0; i < tracks.length; i++) {
            var points = tracks[i].getElementsByTagName('trkpt')
            var pts=[]
            for (let x = 0; x < points.length; x++) { // points.length

                var point = points[x],
                    alt = parseInt(point.getElementsByTagName('ele')[0].firstChild.nodeValue),
                    lat = parseFloat(point.getAttribute('lat')),
                    lng = parseFloat(point.getAttribute('lon')),
                    coord = proj([lat, lng]);

                    //let c = myColor(alt);



                let dot = new THREE.Points(
                    new THREE.Geometry(),
                    new THREE.PointsMaterial({
                        size: 3,
                        sizeAttenuation: false,
                        color: "#F1F131",
                    }));

                dot.geometry.vertices.push(new THREE.Vector3(
                    coord[0], (alt + 50) * unitsPerMeter , -coord[1]));
                scene.add(dot);

                /*var geometry = new THREE.SphereGeometry( 10 * unitsPerMeter, 32, 32 );
                var material = new THREE.MeshPhongMaterial( {color: "#F1F131"} );
                var sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = coord[0];
                sphere.position.y = (alt + 50) * unitsPerMeter;
                sphere.position.z = -coord[1];
                scene.add( sphere );

                pathpoints.push(new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z))

               */
                pts.push(new THREE.Vector3(dot.geometry.vertices.x, dot.geometry.vertices.y, dot.geometry.vertices.z))

            }



            var geometry = new THREE.BufferGeometry().setFromPoints( pts );
            let linematerial = new THREE.LineBasicMaterial({
                color: "#F1F131"
            });
            var line = new THREE.Line( geometry, linematerial );
            scene.add( line );
        }


        render();
        animate();

    }

    //..................Camera Move.......................
    var tween;
    function move(pos) {
        //controls.autoRotate = false;

        var from = {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
        };

        var to = {
            x: pos.x,
            y: pos.y,
            z: pos.z
        };

        tween = new TWEEN.Tween(from)
            .to( to, 4000 )
            .easing( TWEEN.Easing.Quadratic.InOut ) // TWEEN.Easing.Quadratic.InOut ...
            .onUpdate( function ( ) {
                camera.position.set( from.x, from.y, from.z );
                camera.lookAt(new THREE.Vector3( from.x, from.y, from.z ) );
            } )
            .start( );
    }

    function animate() {

        let framesPerSecond = 60;

        setTimeout(function() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();

            raycaster.setFromCamera( mouse, camera );

            var intersects = raycaster.intersectObjects( clickables );

            if ( intersects.length > 0 ) {

                if ( INTERSECTED != intersects[ 0 ].object ) {

                    if ( INTERSECTED ) {
                        INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                    }

                    INTERSECTED = intersects[ 0 ].object;
                    INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    INTERSECTED.material.emissive.setHex( 0xFFFFFF );

                    showImageCanvas(INTERSECTED);
                    //console.log(INTERSECTED)


                }

            } else {

                if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                INTERSECTED = null;

            }

            renderer.render( scene, camera );
            labelRenderer.render( scene, camera );


        }, 1000 / framesPerSecond);





    }

    //..................Places.......................
    //var places = [];
    //places.push("Schatzalp", {'data-latitude':'46.8011922', 'data-longitude':'9.814014308596548', 'data-altitude':'1856'})
    //<nav id="nav"><a href="#" data-longitude="9.814014308596548" data-latitude="46.8011922" data-altitude="1856">Schatzalp</a></nav>
    //https://www.maps.ie/coordinates.html

    //..................Navigation.......................
    //@todo create Navi dynamic

    Array.from(document.getElementById("nav").children).forEach(function(item) {
        //console.log(item);
        item.onclick = function animateCamera(event){
            event.preventDefault();
            const { proj, unitsPerMeter } = tgeo.getProjection(origin, radius);
            //console.log(this.getAttribute('data-longitude'));
            let coord = proj([this.getAttribute('data-latitude'), this.getAttribute('data-longitude')]);
            let pos = new THREE.Vector3( 0, 0, 0 );
            pos.x = coord[0];
            pos.y = (parseInt(this.getAttribute('data-altitude')) + 1000) * unitsPerMeter;
            pos.z = -coord[1];

            move(pos)
        }
    });

</script>

</body>
</html>
